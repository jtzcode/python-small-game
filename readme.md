## 项目札记
1. `textwrap`模块对于格式化输出很有用，尤其是命令行程序。
2. Python通过使用try...except语句提供了一种非常优雅的方式来处理这种情况。这是基于请求原谅比允许更容易（Easier to Ask for Forgiveness thanPermission，EAFP）的原则。
3. 抽象基类最大的一个区别是不能被实例化，但这并不是唯一的区别。抽象基类强制要求派生类实现基类中定义的具体方法。这类似于在定义接口，不需要实例化，只需要一个契约，而且可以通过抽象方法精确控制哪些部分需要被重写。
4. `finally`语句通常被用来在离开函数之前做一些清理任务，一个使用示例就是用来关闭数据库或者文件的连接。为了在Python中实现这个目的，你也可以使用`with`声明。finally语句块是很强的，即使在`except`块中强制return，它还是会被执行。
5. 如果我们继续在这里使用继承原则，它很快就会成为一个维护的噩梦。为什么这样说呢？这是因为你编写的每个类都负责实现和维护自己的移动、跳跃和攻击能力的逻辑。最初，你可能会看到这是一个简单的问题，只是在子类中对功能进行重写。但随着越来越多的角色类型和他们不断增长的能力（移动、跳跃、游泳、防守、隐藏、恢复等），这将是一个艰巨的任务。类和类之间的代码还有可能是重复的。使用继承来区分不同类型的相似操作是个朴素的想法，随着程序演化，不同操作的复杂度越来越高，子类的重写的难度也会增加，且会引入重复代码。
6. 在Python中，没有这样的正式规定来创建和实现一个接口。相反，我们可以使用继承——**具体工厂继承抽象工厂**。如前面所述，我们可以使用Python提供的一级类。
7. 适配器设计模式允许两个不兼容接口之间的交互。适配器模式有两大类，即**类适配器模式**和**对象适配器模式**。在前者中，适配器继承自被适配类。在Python中实现类适配器是可能的，因为该语言支持多重继承。然而，最好选择对象组合（has-a关系）而不是选择继承。在对象适配器模式中，**适配器对象持有一个被适配对象而不是继承被适配类**。对象适配器模式有助于维护被适配对象和客户代码之间的松散耦合，其中客户端不需要任何被适配对象的接口的知识。与类适配器模式相比，这提供了更多的灵活性。
8. 在实现对象适配器时，可以定义一个适配器类，构造函数传入被适配的对象和要适配的方法，前者用于提供已有的方法，后者就是独有的方法。如果有多个方法需要适配，则可以提供一个`set`方法设置独有方法到已有方法的映射。这其实都利用了在Python中函数是**一等公民**的特性。
9. 在寻找变量或函数的定义时，Python首先按照以下顺序搜索命名空间：本地、全局和内置。用更简单的术语来说就是，它首先查找局部变量或函数，然后在模块级别执行搜索，如果找不到任何内容，则查找内置函数或变量。所以，查找局部变量或函数是最快的。使用本地函数代替全局或内置函数可能有助于提高性能。
10. 很多优化方法在程序总执行时间不是很显著时效果不明显，比如减少点操作，但当程序规模变大，可能收获不小的性能提升。
11. Python中的线程同步机制：线程模块提供了一个基于线程并行化的高级接口。为了避免先前讨论的竞争条件，Python采用了一种称为**全局解释器锁（GIL）**的机制。当线程执行一组代码时，需要获取全局锁。此锁确保在Python解释器环境中每次只执行一个线程。GIL的缺点是不能充分利用多处理器。
12. 一方面要提供灵活性的解释代码，另一方面要提供运行速度更快的代码。**JIT编译器**就能做到两全其美。它编译代码，但不是在执行之前编译它，而是在程序执行时或程序执行期间编译。`PyPy`就是这样一个项目，其提供配有JIT编译器的Python语言的另一种实现。